{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\n// an interface for the two primary methods of a LayerZero endpoint:\n//    - send()\n//    - estimateFees()\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _chainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. ie: pay for a specified destination gasAmount, or receive airdropped native gas from the relayer on destination (oh yea!)\n    function send(uint16 _chainId, bytes calldata _destination, bytes calldata _payload, address payable refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainID - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainID, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainID, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getEndpointId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainID - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _dstAddress - the destination chain contract address\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainID - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _dstAddress - the destination chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _libraryAddress - the address of the layerzero library\n    function isValidSendLibrary(address _userApplication, address _libraryAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _libraryAddress - the address of the layerzero library\n    function isValidReceiveLibrary(address _userApplication, address _libraryAddress) external view returns (bool);\n}\n\n"
    },
    "contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice generic config getter/setter for user app\n    function setConfig(uint16 _version, uint _configType, bytes calldata _config) external;\n\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice LayerZero versions. Send/Receive can be different versions during migration\n    function setSendVersion(uint16 version) external;\n\n    function setReceiveVersion(uint16 version) external;\n\n    function getSendVersion() external view returns (uint16);\n\n    function getReceiveVersion() external view returns (uint16);\n\n    // @notice Only in extreme cases where the UA needs to resume the message flow\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/PingPong.sol": {
      "content": "//\n// Note: you will need to fund each deployed contract with gas\n//\n// PingPong sends a LayerZero message back and forth between chains until stopped!\n//\n// Demonstrates:\n//  1. a recursive feature of calling send() from inside lzReceive()\n//  2. how to `estimateFees` for a send()'ing a LayerZero message\n//  3. the contract pays the message fee\n\npragma solidity ^0.8.4;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract PingPong is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    // the LayerZero endpoint calls .send() to send a cross chain message\n    ILayerZeroEndpoint public endpoint;\n    // whether PingPong is ping-ponging\n    bool public pingsEnabled;\n    // event emitted every ping() to keep track of consecutive pings count\n    event Ping(uint pings);\n    // keep track of the totalPings sent\n    uint public numPings;\n\n    // constructor requires the LayerZero endpoint for this chain\n    constructor(address _layerZeroEndpoint){\n        pingsEnabled = true;\n        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n    }\n\n    // disable ping-ponging\n    function disable() external {\n        pingsEnabled = false;\n    }\n\n    // pings the destination chain, along with the current number of pings sent\n    function ping(\n        uint16 _dstChainId,                 // send a ping to this destination chainId\n        address _dstPingPongAddr,           // destination address of PingPong contract\n        uint pings                          // the uint to start at. use 0 as a default\n    )\n    public\n    {\n        require(address(this).balance > 0, \"the balance of this contract is 0. pls send gas for message fees\");\n        require(pingsEnabled, \"pingsEnabled is false. messages stopped\");\n\n        emit Ping(pings);\n\n        // abi.encode() the payload with the number of pings sent\n        bytes memory payload = abi.encode(pings);\n\n        // get the fees we need to pay to LayerZero + Relayer to cover message delivery\n        // see Communicator.sol's .estimateNativeFees() function for more details.\n        (uint messageFee, ) = endpoint.estimateFees(_dstChainId, address(this), payload, false, bytes(\"\"));\n        require(address(this).balance >= messageFee, \"address(this).balance < messageFee. pls send gas for message fees\");\n\n        // send LayerZero message\n        endpoint.send{value:messageFee}(            // {value: messageFee} will be paid out of this contract!\n            _dstChainId,                            // destination chainId\n            abi.encodePacked(_dstPingPongAddr),     // destination address of PingPong\n            payload,                                // abi.encode()'ed bytes\n            payable(msg.sender),                    // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n            address(0x0),                           // 'zroPaymentAddress' unused for this mock/example\n            bytes(\"\")                               // 'txParameters' unused for this mock/example\n        );\n    }\n\n    // receive the bytes payload from the source chain via LayerZero\n    // _srcChainId: the chainId that we are receiving the message from.\n    // _fromAddress: the source PingPong address\n    function lzReceive(uint16 _srcChainId, bytes memory _fromAddress, uint64 _nonce, bytes memory _payload) override external{\n        require(msg.sender == address(endpoint)); // boilerplate! lzReceive must be called by the endpoint for security\n\n        // use assembly to extract the address from the bytes memory parameter\n        address fromAddress;\n        assembly { fromAddress := mload(add(_fromAddress, 20)) }\n\n        // decode the number of pings sent thus far\n        (uint pings) = abi.decode(_payload, (uint));\n\n        // \"recursively\" call ping in order to *pong*     (and increment pings)\n        ++pings;\n        numPings = pings;\n        ping(_srcChainId, fromAddress, pings);\n    }\n\n    function setConfig(\n        uint16, /*_dstChainId*/\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        endpoint.setConfig(endpoint.getSendVersion(), _configType, _config);\n    }\n\n    function getConfig(\n        uint16, /*_dstChainId*/\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view override returns (uint16) {\n        return endpoint.getSendVersion();\n    }\n\n    function getReceiveVersion() external view override returns (uint16) {\n        return endpoint.getReceiveVersion();\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // do nth\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n    receive() external payable {}\n\n}"
    },
    "contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}"
    },
    "contracts/OmniCounter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract OmniCounter is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint;\n    // keep track of how many messages have been received from other chains\n    uint public messageCounter;\n    // required: the LayerZero endpoint which is passed in the constructor\n    ILayerZeroEndpoint public endpoint;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function getCounter() public view returns (uint) {\n        return messageCounter;\n    }\n\n    // overrides lzReceive function in ILayerZeroReceiver.\n    // automatically invoked on the receiving chain after the source chain calls endpoint.send(...)\n    function lzReceive(\n        uint16,\n        bytes memory, /*_fromAddress*/\n        uint64, /*_nonce*/\n        bytes memory /*_payload*/\n    ) external override {\n        require(msg.sender == address(endpoint));\n        messageCounter += 1;\n    }\n\n    // custom function that wraps endpoint.send(...) which will\n    // cause lzReceive() to be called on the destination chain!\n    function incrementCounter(uint16 _dstChainId, bytes calldata _dstCounterMockAddress) public payable {\n        endpoint.send{value: msg.value}(_dstChainId, _dstCounterMockAddress, bytes(\"\"), payable(msg.sender), address(0x0), bytes(\"\"));\n    }\n\n    // _adapterParams (v1)\n    function incrementCounterWithAdapterParamsV1(uint16 _dstChainId, bytes calldata _dstCounterMockAddress, uint gasAmountForDst) public payable {\n        uint16 version = 1;\n        // make look like this: 0x00010000000000000000000000000000000000000000000000000000000000030d40\n        bytes memory _relayerParams = abi.encodePacked(\n            version,\n            gasAmountForDst\n        );\n        endpoint.send{value: msg.value}(_dstChainId, _dstCounterMockAddress, bytes(\"\"), payable(msg.sender), address(0x0), _relayerParams);\n    }\n\n    // _adapterParams (v2)\n    function incrementCounterWithAdapterParamsV2(uint16 _dstChainId, bytes calldata _dstCounterMockAddress, uint gasAmountForDst, uint airdropEthQty, address airdropAddr) public payable {\n        uint16 version = 2;\n        bytes memory _relayerParams = abi.encodePacked(\n            version,\n            gasAmountForDst,\n            airdropEthQty,\n            airdropAddr\n        );\n        endpoint.send{value: msg.value}(_dstChainId, _dstCounterMockAddress, bytes(\"\"), payable(msg.sender), address(0x0), _relayerParams);\n    }\n\n    // call send() to multiple destinations in the same transaction!\n    function incrementCounterMulti(uint16[] calldata _dstChainIds, bytes[] calldata _dstCounterMockAddresses, address payable _refundAddr) public payable {\n        require(_dstChainIds.length == _dstCounterMockAddresses.length, \"_dstChainIds.length, _dstCounterMockAddresses.length not the same\");\n\n        uint numberOfChains = _dstChainIds.length;\n\n        // note: could result in a few wei of dust left in contract\n        uint valueToSend = msg.value.div(numberOfChains);\n\n        // send() each chainId + dst address pair\n        for (uint i = 0; i < numberOfChains; ++i) {\n            // a Communicator.sol instance is the 'endpoint'\n            // .send() each payload to the destination chainId + UA destination address\n            endpoint.send{value: valueToSend}(_dstChainIds[i], _dstCounterMockAddresses[i], bytes(\"\"), _refundAddr, address(0x0), bytes(\"\"));\n        }\n\n        // refund eth if too much was sent into this contract call\n        uint refund = msg.value.sub(valueToSend.mul(numberOfChains));\n        _refundAddr.transfer(refund);\n    }\n\n    function setConfig(\n        uint16, /*_dstChainId*/\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        endpoint.setConfig(endpoint.getSendVersion(), _configType, _config);\n    }\n\n    function getConfig(\n        uint16, /*_dstChainId*/\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        return endpoint.getConfig(endpoint.getSendVersion(), _chainId, address(this), _configType);\n    }\n\n    function setSendVersion(uint16 version) external override {\n        endpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override {\n        endpoint.setReceiveVersion(version);\n    }\n\n    function getSendVersion() external view override returns (uint16) {\n        return endpoint.getSendVersion();\n    }\n\n    function getReceiveVersion() external view override returns (uint16) {\n        return endpoint.getReceiveVersion();\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        // do nth\n    }\n\n    // set the Oracle to be used by this UA for LayerZero messages\n    function setOracle(uint16 dstChainId, address oracle) external { // should technically be onlyOwner but this is a mock\n        uint TYPE_ORACLE = 6; // from UltraLightNode\n        // set the Oracle\n        endpoint.setConfig(\n            endpoint.getSendVersion(),\n            TYPE_ORACLE,\n            abi.encode(dstChainId, oracle)\n        );\n    }\n\n    // allow this contract to receive ether\n    fallback() external payable {}\n    receive() external payable {}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/MultiChainToken.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// deploy this contract to 2+ chains for testing.\n//\n// sendTokens() function works like this:\n//  1. burn local tokens (logic in sendTokens)\n//  2. send a LayerZero message to the destination MultiChainToken address on another chain\n//  3. mint tokens on destination (logic in lzReceive)\ncontract MultiChainToken is ERC20, ILayerZeroReceiver {\n\n    ILayerZeroEndpoint public endpoint;\n\n    // constructor mints tokens to the deployer\n    constructor(string memory name_, string memory symbol_, address _layerZeroEndpoint) ERC20(name_, symbol_){\n        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        _mint(msg.sender, 100 * 10**18); // mint the deployer 100 tokens.\n    }\n\n    // send tokens to another chain.\n    // this function sends the tokens from your address to the same address on the destination.\n    function sendTokens(\n        uint16 _chainId,                            // send tokens to this chainId\n        bytes calldata _dstMultiChainTokenAddr,     // destination address of MultiChainToken\n        uint _qty                                   // how many tokens to send\n    )\n    public\n    payable\n    {\n        // burn the tokens locally.\n        // tokens will be minted on the destination.\n        require(\n            allowance(msg.sender, address(this)) >= _qty,\n            \"You need to approve the contract to send your tokens!\"\n        );\n\n        // and burn the local tokens *poof*\n        _burn(msg.sender, _qty);\n\n        // abi.encode() the payload with the values to send\n        bytes memory payload = abi.encode(msg.sender, _qty);\n\n        // send LayerZero message\n        endpoint.send{value:msg.value}(\n            _chainId,                       // destination chainId\n            _dstMultiChainTokenAddr,        // destination address of MultiChainToken\n            payload,                        // abi.encode()'ed bytes\n            payable(msg.sender),            // refund address (LayerZero will refund any superflous gas back to caller of send()\n            address(0x0),                   // 'zroPaymentAddress' unused for this mock/example\n            bytes(\"\")                       // 'txParameters' unused for this mock/example\n        );\n    }\n\n    // receive the bytes payload from the source chain via LayerZero\n    // _fromAddress is the source MultiChainToken address\n    function lzReceive(uint16 _srcChainId, bytes memory _fromAddress, uint64 _nonce, bytes memory _payload) override external{\n        require(msg.sender == address(endpoint)); // boilerplate! lzReceive must be called by the endpoint for security\n\n        // decode\n        (address toAddr, uint qty) = abi.decode(_payload, (address, uint));\n\n        // mint the tokens back into existence, to the toAddr from the message payload\n        _mint(toAddr, qty);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MultiChainCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\n\n// A classic \"counter\" example with a twist.\n// Deploy two instances of this contract and call incrementCounter()\n// to increment the messageCounter on the destination contract!\ncontract MultiChainCounter is ILayerZeroReceiver {\n\n    // keep track of how many messages have been received from other chains\n    uint public messageCounter;\n\n    // required: the LayerZero endpoint which is passed in the constructor\n    ILayerZeroEndpoint public endpoint;\n\n    // required: the LayerZero endpoint\n    constructor(address _endpoint)  {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    // overrides lzReceive function in ILayerZeroReceiver.\n    // automatically invoked on the receiving chain after\n    // the source chain calls endpoint.send(...)\n    function lzReceive(uint16 , bytes memory , uint64 , bytes memory ) override external {\n        require(msg.sender == address(endpoint));\n        messageCounter += 1;\n    }\n\n    // custom function that wraps endpoint.send(...) which will\n    // cause lzReceive() to be called on the destination chain!\n    function incrementCounter(uint16 _dstChainId, bytes calldata _dstCounterMockAddress) public payable {\n        endpoint.send{value:msg.value}(\n            _dstChainId,\n            _dstCounterMockAddress,\n            bytes(\"\"),\n            payable(msg.sender),\n            address(0x0),\n            bytes(\"\")\n        );\n    }\n\n}\n"
    },
    "contracts/mocks/LayerZeroEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.4;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\n\n// MOCK\n// heavily mocked LayerZero endpoint to facilitate same chain testing of two UserApplications\ncontract LayerZeroEndpointMock is ILayerZeroEndpoint {\n\n    // inboundNonce = [srcChainId][srcAddress].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    // outboundNonce = [dstChainId][srcAddress].\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n\n    uint16 public endpointId;\n    uint public nativeFee;\n    uint public zroFee;\n    uint16 public sendVersion;\n    uint16 public receiveVersion;\n\n    constructor(){\n        endpointId = 1;\n        sendVersion = 1;\n        receiveVersion = 1;\n    }\n\n    // mock helper to set the value returned by `estimateNativeFees`\n    function setEstimatedFees(uint _nativeFee, uint _zroFee) public {\n        nativeFee = _nativeFee;\n        zroFee = _zroFee;\n    }\n\n    // The user application on chain A (the source, or \"from\" chain) sends a message\n    // to the communicator. It includes the following information:\n    //      _chainId            - the destination chain identifier\n    //      _destination        - the destination chain address (in bytes)\n    //      _payload            - a the custom data to send\n    //      _refundAddress      - address to send remainder funds to\n    //      _zroPaymentAddress  - if 0x0, implies user app is paying in native token. otherwise\n    //      txParameters        - optional data passed to the relayer via getPrices()\n    function send(\n        uint16 _chainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata txParameters\n    ) override external payable {\n\n        address destAddr = packedBytesToAddr(_destination);\n        uint64 nonce;\n        {\n            nonce = outboundNonce[_chainId][destAddr]++;\n        }\n\n        bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\n        ILayerZeroReceiver(destAddr).lzReceive(_chainId, bytesSourceUserApplicationAddr, nonce, _payload); // invoke lzReceive\n    }\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external override view returns (uint _nativeFee, uint _zroFee){\n        _nativeFee = nativeFee;\n        _zroFee = zroFee;\n    }\n\n    function packedBytesToAddr(bytes calldata _b) public pure returns (address){\n        address addr;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, sub(_b.offset, 2 ), add(_b.length, 2))\n            addr := mload(sub(ptr,10))\n        }\n        return addr;\n    }\n\n    function addrToPackedBytes(address _a) public pure returns (bytes memory){\n        bytes memory data = abi.encodePacked(_a);\n        return data;\n    }\n\n    // Define what library the UA points too\n    function setSendVersion(uint16 _newVersion) external override {\n        sendVersion = _newVersion;\n    }\n\n    function setReceiveVersion(uint16 _newVersion) external override {\n        receiveVersion = _newVersion;\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n        //\n    }\n\n    function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\n        return inboundNonce[_chainID][_srcAddress];\n    }\n\n    function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_chainID][_srcAddress];\n    }\n\n    function getEndpointId() external view override returns (uint16) {\n        return endpointId;\n    }\n\n    function getSendVersion() external view override returns (uint16) {\n        return 1;\n    }\n\n    function getReceiveVersion() external view override returns (uint16) {\n        return 1;\n    }\n\n    function setConfig(\n        uint16, /*_dstChainId*/\n        uint _configType,\n        bytes memory _config\n    ) external override {\n        //endpoint.setConfig(endpoint.getSendVersion(), _configType, _config);\n    }\n\n    function getConfig(\n        uint16, /*_dstChainId*/\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view override returns (bytes memory) {\n        //return endpoint.getConfig(endpoint.getSendVersion(), _chainId, address(this), _configType);\n    }\n\n    function isValidSendLibrary(address _ua, address _libraryAddress) external view override returns (bool) {\n        // LibraryConfig storage uaConfig = uaConfigLookup[_ua];\n        // address sendLib = address(uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendLibrary : uaConfig.sendLibrary);\n        // return sendLib == _libraryAddress;\n    }\n\n    function isValidReceiveLibrary(address _ua, address _libraryAddress) external view override returns (bool) {\n        // LibraryConfig storage uaConfig = uaConfigLookup[_ua];\n        // address receiveLib = uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveLibraryAddress : uaConfig.receiveLibraryAddress;\n        // return receiveLib == _libraryAddress;\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress) external view override returns (bool) {\n        // StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress][_dstAddress];\n        // return sp.stored;\n        return false;\n    }\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress) external override {\n        // mocked, ignore. will never happen\n    }\n\n}\n\n"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "//// SPDX-License-Identifier: Unlicense\n///*\n// * @title Solidity Bytes Arrays Utils\n// * @author Gonalo S <goncalo.sa@consensys.net>\n// *\n// * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n// *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n// */\n//pragma solidity 0.7.6;\n//\n//\n//library BytesLib {\n//    function concat(\n//        bytes memory _preBytes,\n//        bytes memory _postBytes\n//    )\n//    internal\n//    pure\n//    returns (bytes memory)\n//    {\n//        bytes memory tempBytes;\n//\n//        assembly {\n//        // Get a location of some free memory and store it in tempBytes as\n//        // Solidity does for memory variables.\n//            tempBytes := mload(0x40)\n//\n//        // Store the length of the first bytes array at the beginning of\n//        // the memory for tempBytes.\n//            let length := mload(_preBytes)\n//            mstore(tempBytes, length)\n//\n//        // Maintain a memory counter for the current write location in the\n//        // temp bytes array by adding the 32 bytes for the array length to\n//        // the starting location.\n//            let mc := add(tempBytes, 0x20)\n//        // Stop copying when the memory counter reaches the length of the\n//        // first bytes array.\n//            let end := add(mc, length)\n//\n//            for {\n//            // Initialize a copy counter to the start of the _preBytes data,\n//            // 32 bytes into its memory.\n//                let cc := add(_preBytes, 0x20)\n//            } lt(mc, end) {\n//            // Increase both counters by 32 bytes each iteration.\n//                mc := add(mc, 0x20)\n//                cc := add(cc, 0x20)\n//            } {\n//            // Write the _preBytes data into the tempBytes memory 32 bytes\n//            // at a time.\n//                mstore(mc, mload(cc))\n//            }\n//\n//        // Add the length of _postBytes to the current length of tempBytes\n//        // and store it as the new length in the first 32 bytes of the\n//        // tempBytes memory.\n//            length := mload(_postBytes)\n//            mstore(tempBytes, add(length, mload(tempBytes)))\n//\n//        // Move the memory counter back from a multiple of 0x20 to the\n//        // actual end of the _preBytes data.\n//            mc := end\n//        // Stop copying when the memory counter reaches the new combined\n//        // length of the arrays.\n//            end := add(mc, length)\n//\n//            for {\n//                let cc := add(_postBytes, 0x20)\n//            } lt(mc, end) {\n//                mc := add(mc, 0x20)\n//                cc := add(cc, 0x20)\n//            } {\n//                mstore(mc, mload(cc))\n//            }\n//\n//        // Update the free-memory pointer by padding our last write location\n//        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n//        // next 32 byte block, then round down to the nearest multiple of\n//        // 32. If the sum of the length of the two arrays is zero then add\n//        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n//            mstore(0x40, and(\n//            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n//            not(31) // Round down to the nearest 32 bytes.\n//            ))\n//        }\n//\n//        return tempBytes;\n//    }\n//\n//    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n//        assembly {\n//        // Read the first 32 bytes of _preBytes storage, which is the length\n//        // of the array. (We don't need to use the offset into the slot\n//        // because arrays use the entire slot.)\n//            let fslot := sload(_preBytes.slot)\n//        // Arrays of 31 bytes or less have an even value in their slot,\n//        // while longer arrays have an odd value. The actual length is\n//        // the slot divided by two for odd values, and the lowest order\n//        // byte divided by two for even values.\n//        // If the slot is even, bitwise and the slot with 255 and divide by\n//        // two to get the length. If the slot is odd, bitwise and the slot\n//        // with -1 and divide by two.\n//            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n//            let mlength := mload(_postBytes)\n//            let newlength := add(slength, mlength)\n//        // slength can contain both the length and contents of the array\n//        // if length < 32 bytes so let's prepare for that\n//        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n//            switch add(lt(slength, 32), lt(newlength, 32))\n//            case 2 {\n//            // Since the new array still fits in the slot, we just need to\n//            // update the contents of the slot.\n//            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n//                sstore(\n//                _preBytes.slot,\n//                // all the modifications to the slot are inside this\n//                // next block\n//                add(\n//                // we can just add to the slot contents because the\n//                // bytes we want to change are the LSBs\n//                fslot,\n//                add(\n//                mul(\n//                div(\n//                // load the bytes from memory\n//                mload(add(_postBytes, 0x20)),\n//                // zero all bytes to the right\n//                exp(0x100, sub(32, mlength))\n//                ),\n//                // and now shift left the number of bytes to\n//                // leave space for the length in the slot\n//                exp(0x100, sub(32, newlength))\n//                ),\n//                // increase length by the double of the memory\n//                // bytes length\n//                mul(mlength, 2)\n//                )\n//                )\n//                )\n//            }\n//            case 1 {\n//            // The stored value fits in the slot, but the combined value\n//            // will exceed it.\n//            // get the keccak hash to get the contents of the array\n//                mstore(0x0, _preBytes.slot)\n//                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n//\n//            // save new length\n//                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n//\n//            // The contents of the _postBytes array start 32 bytes into\n//            // the structure. Our first read should obtain the `submod`\n//            // bytes that can fit into the unused space in the last word\n//            // of the stored array. To get this, we read 32 bytes starting\n//            // from `submod`, so the data we read overlaps with the array\n//            // contents by `submod` bytes. Masking the lowest-order\n//            // `submod` bytes allows us to add that value directly to the\n//            // stored value.\n//\n//                let submod := sub(32, slength)\n//                let mc := add(_postBytes, submod)\n//                let end := add(_postBytes, mlength)\n//                let mask := sub(exp(0x100, submod), 1)\n//\n//                sstore(\n//                sc,\n//                add(\n//                and(\n//                fslot,\n//                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n//                ),\n//                and(mload(mc), mask)\n//                )\n//                )\n//\n//                for {\n//                    mc := add(mc, 0x20)\n//                    sc := add(sc, 1)\n//                } lt(mc, end) {\n//                    sc := add(sc, 1)\n//                    mc := add(mc, 0x20)\n//                } {\n//                    sstore(sc, mload(mc))\n//                }\n//\n//                mask := exp(0x100, sub(mc, end))\n//\n//                sstore(sc, mul(div(mload(mc), mask), mask))\n//            }\n//            default {\n//            // get the keccak hash to get the contents of the array\n//                mstore(0x0, _preBytes.slot)\n//            // Start copying to the last used word of the stored array.\n//                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n//\n//            // save new length\n//                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n//\n//            // Copy over the first `submod` bytes of the new data as in\n//            // case 1 above.\n//                let slengthmod := mod(slength, 32)\n//                let mlengthmod := mod(mlength, 32)\n//                let submod := sub(32, slengthmod)\n//                let mc := add(_postBytes, submod)\n//                let end := add(_postBytes, mlength)\n//                let mask := sub(exp(0x100, submod), 1)\n//\n//                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n//\n//                for {\n//                    sc := add(sc, 1)\n//                    mc := add(mc, 0x20)\n//                } lt(mc, end) {\n//                    sc := add(sc, 1)\n//                    mc := add(mc, 0x20)\n//                } {\n//                    sstore(sc, mload(mc))\n//                }\n//\n//                mask := exp(0x100, sub(mc, end))\n//\n//                sstore(sc, mul(div(mload(mc), mask), mask))\n//            }\n//        }\n//    }\n//\n//    function slice(\n//        bytes memory _bytes,\n//        uint256 _start,\n//        uint256 _length\n//    )\n//    internal\n//    pure\n//    returns (bytes memory)\n//    {\n//        require(_length + 31 >= _length, \"slice_overflow\");\n//        require(_start + _length >= _start, \"slice_overflow\");\n//        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n//\n//        bytes memory tempBytes;\n//\n//        assembly {\n//            switch iszero(_length)\n//            case 0 {\n//            // Get a location of some free memory and store it in tempBytes as\n//            // Solidity does for memory variables.\n//                tempBytes := mload(0x40)\n//\n//            // The first word of the slice result is potentially a partial\n//            // word read from the original array. To read it, we calculate\n//            // the length of that partial word and start copying that many\n//            // bytes into the array. The first word we copy will start with\n//            // data we don't care about, but the last `lengthmod` bytes will\n//            // land at the beginning of the contents of the new array. When\n//            // we're done copying, we overwrite the full first word with\n//            // the actual length of the slice.\n//                let lengthmod := and(_length, 31)\n//\n//            // The multiplication in the next line is necessary\n//            // because when slicing multiples of 32 bytes (lengthmod == 0)\n//            // the following copy loop was copying the origin's length\n//            // and then ending prematurely not copying everything it should.\n//                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n//                let end := add(mc, _length)\n//\n//                for {\n//                // The multiplication in the next line has the same exact purpose\n//                // as the one above.\n//                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n//                } lt(mc, end) {\n//                    mc := add(mc, 0x20)\n//                    cc := add(cc, 0x20)\n//                } {\n//                    mstore(mc, mload(cc))\n//                }\n//\n//                mstore(tempBytes, _length)\n//\n//            //update free-memory pointer\n//            //allocating the array padded to 32 bytes like the compiler does now\n//                mstore(0x40, and(add(mc, 31), not(31)))\n//            }\n//            //if we want a zero-length slice let's just return a zero-length array\n//            default {\n//                tempBytes := mload(0x40)\n//\n//                mstore(0x40, add(tempBytes, 0x20))\n//            }\n//        }\n//\n//        return tempBytes;\n//    }\n//\n//    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n//        require(_start + 20 >= _start, \"toAddress_overflow\");\n//        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n//        address tempAddress;\n//\n//        assembly {\n//            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n//        }\n//\n//        return tempAddress;\n//    }\n//\n//    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n//        require(_start + 1 >= _start, \"toUint8_overflow\");\n//        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n//        uint8 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x1), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n//        require(_start + 2 >= _start, \"toUint16_overflow\");\n//        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n//        uint16 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x2), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n//        require(_start + 4 >= _start, \"toUint32_overflow\");\n//        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n//        uint32 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x4), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n//        require(_start + 8 >= _start, \"toUint64_overflow\");\n//        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n//        uint64 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x8), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n//        require(_start + 12 >= _start, \"toUint96_overflow\");\n//        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n//        uint96 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0xc), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n//        require(_start + 16 >= _start, \"toUint128_overflow\");\n//        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n//        uint128 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x10), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n//        require(_start + 32 >= _start, \"toUint256_overflow\");\n//        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n//        uint256 tempUint;\n//\n//        assembly {\n//            tempUint := mload(add(add(_bytes, 0x20), _start))\n//        }\n//\n//        return tempUint;\n//    }\n//\n//    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n//        require(_start + 32 >= _start, \"toBytes32_overflow\");\n//        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n//        bytes32 tempBytes32;\n//\n//        assembly {\n//            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n//        }\n//\n//        return tempBytes32;\n//    }\n//\n//    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n//        bool success = true;\n//\n//        assembly {\n//            let length := mload(_preBytes)\n//\n//        // if lengths don't match the arrays are not equal\n//            switch eq(length, mload(_postBytes))\n//            case 1 {\n//            // cb is a circuit breaker in the for loop since there's\n//            //  no said feature for inline assembly loops\n//            // cb = 1 - don't breaker\n//            // cb = 0 - break\n//                let cb := 1\n//\n//                let mc := add(_preBytes, 0x20)\n//                let end := add(mc, length)\n//\n//                for {\n//                    let cc := add(_postBytes, 0x20)\n//                // the next line is the loop condition:\n//                // while(uint256(mc < end) + cb == 2)\n//                } eq(add(lt(mc, end), cb), 2) {\n//                    mc := add(mc, 0x20)\n//                    cc := add(cc, 0x20)\n//                } {\n//                // if any of these checks fails then arrays are not equal\n//                    if iszero(eq(mload(mc), mload(cc))) {\n//                    // unsuccess:\n//                        success := 0\n//                        cb := 0\n//                    }\n//                }\n//            }\n//            default {\n//            // unsuccess:\n//                success := 0\n//            }\n//        }\n//\n//        return success;\n//    }\n//\n//    function equalStorage(\n//        bytes storage _preBytes,\n//        bytes memory _postBytes\n//    )\n//    internal\n//    view\n//    returns (bool)\n//    {\n//        bool success = true;\n//\n//        assembly {\n//        // we know _preBytes_offset is 0\n//            let fslot := sload(_preBytes.slot)\n//        // Decode the length of the stored array like in concatStorage().\n//            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n//            let mlength := mload(_postBytes)\n//\n//        // if lengths don't match the arrays are not equal\n//            switch eq(slength, mlength)\n//            case 1 {\n//            // slength can contain both the length and contents of the array\n//            // if length < 32 bytes so let's prepare for that\n//            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n//                if iszero(iszero(slength)) {\n//                    switch lt(slength, 32)\n//                    case 1 {\n//                    // blank the last byte which is the length\n//                        fslot := mul(div(fslot, 0x100), 0x100)\n//\n//                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n//                        // unsuccess:\n//                            success := 0\n//                        }\n//                    }\n//                    default {\n//                    // cb is a circuit breaker in the for loop since there's\n//                    //  no said feature for inline assembly loops\n//                    // cb = 1 - don't breaker\n//                    // cb = 0 - break\n//                        let cb := 1\n//\n//                    // get the keccak hash to get the contents of the array\n//                        mstore(0x0, _preBytes.slot)\n//                        let sc := keccak256(0x0, 0x20)\n//\n//                        let mc := add(_postBytes, 0x20)\n//                        let end := add(mc, mlength)\n//\n//                    // the next line is the loop condition:\n//                    // while(uint256(mc < end) + cb == 2)\n//                        for {} eq(add(lt(mc, end), cb), 2) {\n//                            sc := add(sc, 1)\n//                            mc := add(mc, 0x20)\n//                        } {\n//                            if iszero(eq(sload(sc), mload(mc))) {\n//                            // unsuccess:\n//                                success := 0\n//                                cb := 0\n//                            }\n//                        }\n//                    }\n//                }\n//            }\n//            default {\n//            // unsuccess:\n//                success := 0\n//            }\n//        }\n//\n//        return success;\n//    }\n//}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}